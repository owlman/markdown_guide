# 第3章 撰写一篇论文

## 本章提要

在上一章中，我们通过演示一篇论文的前期准备工作，为大家介绍了标题、列表、超链接以及待办事项四种`Markdown`标记的用法。接下来，我们就要开始正式撰写论文了。和之前一样，我们仍会继续以论文写作的过程为导引，逐步深入地介绍其余主要的`Markdown`标记，以及它们的具体使用。这其中既会包含用来表示段落、强调、引用、代码这些基本元素的原生`Markdown`标记，也会涉及到与表格、图形相关的扩展标记，以及它们的基本用法。

## 3.1 VSCode编辑器

依据我们在上一章中所划分的应用场景，论文的写作应该属于在本地计算机上的编辑工作，而且根据之前拟定的论文大纲来看，我接下来要撰写的是一部可分为七个章节的作品。为了便于后期对作品进行版本控制和审阅修改，我将每一章都存储成了一个独立的`Markdown`文档。鉴于接下来的这部分工作都将通过支持项目管理功能的VSCode编辑器来完成。所以，我们要先花一点时间简单介绍一下这款编辑器的基本使用。

在VSCode编辑器中，项目管理是以「工作区」为单位来组织的。所以，我们首先要做的第一件事就是创建一个名为「毕业论文」的VSCode工作区，其操作步骤如下：

1. 利用本地文件管理系统创建一个名为「毕业论文」的空文件夹，并根据论文大纲中的一级标题创建七个扩展名为`.md`的文本文档，每一个文档对应论文的一个章节：

   ![创建项目文件夹](img/3-1.png)

2. 在VSCode编辑器中单击菜单「文件 - 打开文件夹...」，打开上面所创建的文件夹：

   ![创建VSCode工作区](img/3-2.png)

3. 在VSCode编辑器中单击菜单「文件 - 将工作区另存为...」，保存为「毕业论文」。

当然了，如果读者使用的是其他本地编辑器（譬如Sublime Text、Atom或Typora等），它们也都有与「工作区」类似的项目管理单位，操作大同小异，各位大可以自行举一反三，做点随机应变即可。接下来，就让我们在VSCode编辑器中打开名为「01_系统概述.md」的文档,将论文大纲中第一章的部分录入，顺便来看一下这款编辑器的布局吧：

![开始撰写论文](img/3-3.png)

如你所见，整个编辑器除去最顶部的菜单栏和最左侧的工具栏，其主体部分主要被分成了三个部分：左侧的上半部分是「文件管理器」，其中显示的是当前工作区中的所有文档；左侧下部分是文档的「大纲视图」，各位可以看到，我们刚刚录入的标题内容已经以大纲的形式同步显示在这一部分了；右侧就是文档的编辑器，这篇论文的`Markdown`编码就是要这一区域中进行。

除此之外，我们在具体编写`Markdown`文档时还可以打开「预览视图」，以实时监控`Markdown`编码的渲染效果。打开「预览视图」的操作非常简单，步骤如下：

1. 在VSCode编辑器中使用快捷键`Ctrl+Shift+P`打开命令模式，从中选择「Markdown：打开侧边预览」：

   ![VScode编辑器的命令模式](img/3-4.png)

   然后我们就会在右侧看见当前文档的预览：

   ![Markdown文档的预览视图](img/3-5.png)

2. 如果我们想更专注于当前文档的编写，也可以选择隐藏掉左侧的「文件管理 器」和「大纲视图」，只需要用鼠标单击一下最左侧工具栏中的第一个图标，或者使用快捷键`Ctrl+Shift+P`打开命令模式，从中选择「视图：切换侧边栏可见性」，然后编辑器的主要区域就只剩下编码区和预览区了：

   ![隐藏文件管理与大纲视图](img/3-6.png)

   如果我们想重新打开侧边栏，只需要再次用鼠标单击一下最左侧工具栏中的第一个图标，或者使用快捷键`Ctrl+Shift+P`打开命令模式，从中选择「视图：切换侧边栏可见性」即可。

接下来，就让我们正式进入论文的撰写工作吧！

## 3.2 文字与代码

我们之所以要用`Markdown`来写作，而不直接使用无格式的纯文本，主要是为了将作品中的文字标记成各种元素，用这些元素来表达各种不同的语义。因此，我们在使用`Markdown`标记时，脑中必须要有一个清晰的概念：*我们标记的是语义，不是外观样式*。譬如，被标记**加粗**或**倾斜**的文字代表的应该是作者对这段文字的着重强调，而不作者认为这段文字加粗或倾斜会比较好看。同样的，被标记为**引用**的文字它代表的则是作者对其他作品的引述，而不是作者认为某段文字应该有个文本框。

这也就意味着，如果我们想用好`Markdown`标记，首先就要先熟悉这些标记所代表的语义。下面，就让我们从最基本的文字元素开始。

### 3.2.1 段落与换行

在`Markdown`中，段落是由一行或多行文本组成的语义元素，对应的是`HTML`中`<p>段落</p>`标记。该元素的前后必须各有一个以上的空白行，并且段落之间无论有多少个空行，在渲染效果中都只显示一个空行。举个例子，下面这段文字是著名宋词《水调歌头-明月几时有》的原文：

```Markdown
明月几时有？把酒问青天。不知天上宫阙，今夕是何年？我欲乘风归去，又恐琼楼玉宇，高处不胜寒。起舞弄清影，何似在人间？
转朱阁，低绮户，照无眠。不应有恨，何事长向别时圆？人有悲欢离合，月有阴晴圆缺，此事古难全。但愿人长久，千里共婵娟。
```

我们将会看到，虽然上面这段文字是分做两行被录入的（这里不考虑因编辑器自身大小而形成的自动换行），但在渲染效果中，这段文字不仅只显示为一个段落，连我们输入的逻辑换行符也消失了，只有软件界面自身形成的自动换行。

> 明月几时有？把酒问青天。不知天上宫阙，今夕是何年？我欲乘风归去，又恐琼楼玉宇，高处不胜寒。起舞弄清影，何似在人间？
> 转朱阁，低绮户，照无眠。不应有恨，何事长向别时圆？人有悲欢离合，月有阴晴圆缺，此事古难全。但愿人长久，千里共婵娟。

现在，让我们在刚才输入的两行之间再插入一个空行（也可以插入多个空行，效果是一样的）：

```Markdown
明月几时有？把酒问青天。不知天上宫阙，今夕是何年？我欲乘风归去，又恐琼楼玉宇，高处不胜寒。起舞弄清影，何似在人间？

转朱阁，低绮户，照无眠。不应有恨，何事长向别时圆？人有悲欢离合，月有阴晴圆缺，此事古难全。但愿人长久，千里共婵娟。
```

然后我们就会看到，这一回文字的渲染效果变成了两个段落，对应的是这篇词文的上下阕：

> 明月几时有？把酒问青天。不知天上宫阙，今夕是何年？我欲乘风归去，又恐琼楼玉宇，高处不胜寒。起舞弄清影，何似在人间？
>
> 转朱阁，低绮户，照无眠。不应有恨，何事长向别时圆？人有悲欢离合，月有阴晴圆缺，此事古难全。但愿人长久，千里共婵娟。

然而，这种书写方式依然不符合中国古诗词的优雅风格，因为这篇宋词除了分上下阕，通常在阕内也是要分行的，但这种分行不分段的书写形式（即输入`HTML`中的`<br />`标记）在`Markdown`中应该如何实现呢？答案是：*在每一行结尾处先输入两个空格，然后再键入回车键*：

```Markdown
明月几时有？把酒问青天。                <!--行尾应有两个空格-->
不知天上宫阙，今夕是何年？              <!--行尾应有两个空格-->
我欲乘风归去，又恐琼楼玉宇，高处不胜寒。  <!--行尾应有两个空格-->
起舞弄清影，何似在人间？               <!--行尾应有两个空格-->

转朱阁，低绮户，照无眠。                <!--行尾应有两个空格-->
不应有恨，何事长向别时圆？              <!--行尾应有两个空格-->
人有悲欢离合，月有阴晴圆缺，此事古难全。  <!--行尾应有两个空格-->
但愿人长久，千里共婵娟。               <!--行尾应有两个空格-->
```

请注意：这里的`<!-- 注释信息 -->`是`HTML`中的注释标记，由于兼容性的关系，`HTML`标记通常都可以应用在`Markdown`文档中。我们可以用该标记来提示文档在后续处理中需要留意的信息，譬如这里的每个段内分行处都有两个空格，而空格是不可见字符，所以就有必要做个特别提示。接下来，就让我们来看看上述编码的渲染效果吧，这段文字的呈现已经完全符合我们对中国古诗词的一贯书写方式了：

> 明月几时有？把酒问青天。  
> 不知天上宫阙，今夕是何年？  
> 我欲乘风归去，又恐琼楼玉宇，高处不胜寒。  
> 起舞弄清影，何似在人间？
>
> 转朱阁，低绮户，照无眠。  
> 不应有恨，何事长向别时圆？  
> 人有悲欢离合，月有阴晴圆缺，此事古难全。  
> 但愿人长久，千里共婵娟。

下面，让我们重新回到论文的撰写工作中，先来看看下面这几段文字的渲染效果：

![论文的某部分文本](img/3-7.png)

如你所见，上图不仅有一般性的文字段落，列表中的每个列表项也可以由一个或多个段落组成。当然，如果某个列表项有多个段落，需要注意一下其第一个段落之后的缩进格式。譬如：

![列表中的段落](img/3-8.png)

但是，如果我们没有做适当的缩进，譬如去掉列表项1的第二个段落之前的空格，大家就会看到该段落脱离了列表，成为了普通的文本段落：

![未作正确缩进的列表段落](img/3-9.png)

### 3.2.2 文字强调

在处理完文本的分段和分行之后，让我们再回头仔细观察一下刚才撰写的论文内容，譬如对于其中的第一个列表：

> - ASP：全称 Active Server Pages，是一种以 VBScript 为编程语言的服务器端脚本。特点是易学易用，能快速上手，无需多少学习成本，非常适合本系统这种小型站点的服务器端开发，也能代表比较典型的传统服务器脚本。
>
> - JavaScript：目前普遍采用的一种浏览器端脚本语言。尽管在一些细节上存在着各种浏览器之间的兼容问题，但市场已经证明了它的可靠性，将其应用于本系统的浏览器端处理也是合适的。
>
> - HTML：这是所有 Web 技术的基础，可行性无须置疑。
>
> - Access 数据库：Microsoft Office 组件之一，具有容易获得、功能完整、上手简单、便于移植的特点，适合于本系统的开发和发布。

相信大家都会觉得这段文字看上去难免有些苍白，缺乏重点。而从作者的角度来说，我们肯定会希望能凸显每个列表项的主题以及其中的一些关键字，以便提示阅读时应注意的重点。在这种情况下，我们就需要用到能表达强调语义的元素了。在`Markdown`中，用于表示强调的语义元素主要有三种，分别是粗体显示（对应`HTML`的`<b>粗体显示</b>`标记）、斜体显示（对应`HTML`中`<i>斜体显示</i>`标记）与粗体+斜体显示。这些语义元素又各自有一到两种不同风格的语法，下面我们就逐一来演示一下这些语法及其渲染效果：

| Markdown语法             | 相应渲染效果             |
|-------------------------|------------------------|
| `普通文本示例`            | 普通文本示例             |
| `**粗体文本示例1**`       | **粗体文本示例1**        |
| `__粗体文本示例2__`       | __粗体文本示例2__        |
| `*斜体文本示例1*`         | *斜体文本示例1*          |
| `_斜体文本示例2_`         | _斜体文本示例2_          |
| `***粗体+斜体文本示例1***` | ***粗体+斜体文本示例1*** |
| `___粗体+斜体文本示例2___` | ___粗体+斜体文本示例2___ |
| `~~删除文本示例~~`        | ~~删除文本示例~~         |

在使用以上语义元素时，我们应该要注意保持语法的一致性。也就是说，在选定了一种粗体或斜体语法之后，至少要在同一文档或同一作品中坚持使用相同的语法。这种语法上的一致性不仅有利于文档的可读性，也有利于文档的后续批量化处理。现在，就让我们在之前提到的论文文本加入一些用于表示强调的标记吧：

```Markdown
- **ASP**：全称 Active Server Pages，是一种以 VBScript 为编程语言的*服务器端脚本*。特点是易学易用，能快速上手，无需多少学习成本，非常适合本系统这种小型站点的服务器端开发，也能代表比较典型的传统服务器脚本。

- **JavaScript**：目前普遍采用的一种*浏览器端脚本语言*。尽管在一些细节上存在着各种浏览器之间的兼容问题，但市场已经证明了它的可靠性，将其应用于本系统的浏览器端处理也是合适的。

- **HTML**：这是所有 Web 技术的基础，可行性无须置疑。

- **Access**：Microsoft Office 中的*数据库*组件，具有容易获得、功能完整、上手简单、便于移植的特点，适合于本系统的开发和发布。
```

如你所见，这一回我们用粗体凸显了每个列表项的主题，并用斜体凸显了其中的一些关键字。这样一来，当我们再次查看这段文字的渲染效果时，这段文字给人的感觉就好了不少：

> - **ASP**：全称 Active Server Pages，是一种以 VBScript 为编程语言的*服务器端脚本*。特点是易学易用，能快速上手，无需多少学习成本，非常适合本系统这种小型站点的服务器端开发，也能代表比较典型的传统服务器脚本。
>
> - **JavaScript**：目前普遍采用的一种*浏览器端脚本语言*。尽管在一些细节上存在着各种浏览器之间的兼容问题，但市场已经证明了它的可靠性，将其应用于本系统的浏览器端处理也是合适的。
>
> - **HTML**：这是所有 Web 技术的基础，可行性无须置疑。
>
> - **Access**：Microsoft Office 中的*数据库*组件，具有容易获得、功能完整、上手简单、便于移植的特点，适合于本系统的开发和发布。

### 3.2.3 引用外部文本

在写作过程中，我们难免要引用一些名人名言或其他作品中的某段话，这时候就需要用到能标记出引用文本的元素了。在`Markdown`中，标记应用文本的语法很简单，下面我们就在有道云笔记中演示一下：

![引用外部文本](img/3-11.png)

如你所见，想要标记一段引用文本，只需要在这段文本的每一行之前加上一个“`>`”符号即可。请注意：这里所说的“行”，指的是我们输入的逻辑行，包括用于分段的空白行，但不包含软件界面自身形成的自动换行。

除此之外，我们还可以做一些嵌套引用，即我们引用的文本自身也引用了其他地方的文本，譬如：

```Markdown
> 自五四运动以来，太多话被塞到了鲁迅的嘴里，于是就有了一个共识：
> > 大家都认为鲁迅说过：
> > > 这句话不是我说的！
```

我们可以来看看上述编码的渲染效果：

> 自五四运动以来，太多话被塞到了鲁迅的嘴里，于是就有了一个共识：
> > 大家都认为鲁迅说过：
> >
> > > 这句话不是我说的！

当然，引用文本中自然也能使用其他`Markdown`元素，包括标题、列表等。这些都不在话下，使用方式也完全相同，这里就不多累述了。

### 3.2.4 展示程序代码

由于我们正在撰写的是一篇计算机专业的论文，展示程序代码显然是绕不过去的一个环节。在显示代码时，我们最低限度的要求是被标记为代码的文本必须要将其所有字符原样呈现，也就是说，在表示代码语义的元素内，所有`Markdown`的语法标记（譬如“`#`”、“`*`”等字符）都会失效，回归到其字符本身。在`Markdown`中，用来标记代码的语义元素主要有两种：

- **行内代码**：顾名思义，就是将代码显示在普通的文本行之内。这种标记代码的语法就是在代码文本的两侧各加一个“ ` ”符号（输入该符号的按键在普通键盘左侧的第一列键中，位于数字1键的左边）。例如：

  ```Markdown
  在C语言中。我们可以通过`printf(“Hello World！”)`来在终端输出“Hello World！”字样。
  ```

  其渲染效果如下：

  > 在C语言中。我们可以通过`printf(“Hello World！”)`来在终端输出“Hello World！”字样。

- **代码区块**：顾名思义，就是将代码显示在一个单独的区块中，通常用于显示多行代码。标记代码区块的语法就是在代码文本的之前和之后都插入一个只包含三个“ ` ”符号的行，或者对代码文本整体做一个制表符（即四个空格）的缩进。例如：

  ![代码区块](img/3-12.png)

  另外，为了让`Markdown`阅读器或转换器更好地渲染目标代码的高亮效果，我们通常还会在第一行的三个“ ` ”符号之后声明一下这段代码所使用的编程语言，譬如：

  ![声明程序语言](img/3-13.png)

下面，让我们再次回到论文的撰写工作中来，论述一下系统的实现部分吧，这一回要展示的是古老的`ASP`代码了：

![在论文中录入实现代码](img/3-14.png)

### 3.2.5 其他文本元素

在写作过程中，我们有时候还会用到一些不太常见，且难以归类的文本元素。在这一节中，我们就来简单介绍一下这些元素。

首先，我们要介绍一些**特殊字符**，这些字符由于`Markdown`自身的语法及其兼容`HTML`的关系，在文本中的某些地方会具有一些特殊作用。在这种情况下，如果我们不想这些字符显示为行内代码，就需要在这些字符前面加上一个反斜杠“\\”来显示它们了。这些字符的数量并不多，我们可以在这里将它们罗列一下：

| Markdown语法 | 渲染效果 | 符号说明 |
|:-----------:|:-------:|:-------:|
| `\\`        | \\      | 反斜杠   |
| `\*`        | \*      | 星 号    |
| `\_`        | \_      | 下划线   |
| `\{ \}`     | \{ \}   | 花括号   |
| `\[ \]`     | \[ \]   | 方括号   |
| `\( \)`     | \( \)   | 圆括号   |
| `\#`        | \#      | 井号    |
| `\+`        | \+      | 加号    |
| `\-`        | \-      | 减号    |
| `\.`        | \.      | 英文句点 |
| `\!`        | \!      | 英文叹号 |

除了以上这些特殊字符之外，我们有时候还会用到一个叫做**分隔线**的文本元素。分隔线有三种不同的符号（分别是星号`*`、减号`-`和下划线`_`）以及下面三种不同的语法风格：

![分割线的三种风格](img/3-15.png)

当然，这里同样要提醒大家注意保持语法的一致性，当我们选择了一种分割线符号和语法风格之后，请至少在同一文档或同一作品中坚持使用相同的符号和语法风格。这种一致性不仅有利于文档的可读性，也有利于文档的后续批量化处理。

最后，还有一个语义元素也需要稍微关注一下，那就是**脚注**元素。在撰写文章时，我们总免不了要对文中的某些句子和单词加一些注解。在`Markdown`中，我们可以这样在文章中添加脚注：

```Markdown
在这个示例段落中，我们打算为大家演示一下如何在 Markdown 文档中添加脚注，以便大家对脚注[^1]这个语义元素[^2]有一个直观的认知。

* * *

[^1]:这是第一个脚注。

[^2]:这是第二个脚注。
```

如你所见，如果我们想对某一文本添加一个脚注，就在该文本后面添加一个与之对应脚注编号（譬如`[^1]`、`[^2]`），然后，在别处另起一个段落，通常会选择在某一部分或整篇文章的结尾处，以该编号加英文冒号为开头（譬如`[^1]:`）来编写脚注的内容。下面，我们来看看上述编码的渲染效果：

![为文本添加脚注](img/3-16.png)

## 3.3 表格与图形

在编写一篇计算机专业论文的过程中，我们除了会用到文本和代码相关的基本元素之外，通常还需要绘制各种图表，这就需要涉及到`Markdown`的一系列扩展语法。在这一节中，我们就来逐一介绍这些特殊的语义元素。

### 3.3.1 绘制表格

在`Markdown`中，绘制表格主要有两种方式。首先，针对结构简单的表格，`Markdown`提供了一套自己的语法。下面，我们就先来示范一下这种语法：

```Markdown
| 姓名 | 性别 | 年龄 | 婚姻状况 |
|-----|-----:|:---:|:--------|
| 张三 | 男   | 25  | 未婚     |
| 李四 | 女   | 35  | 已婚     |
| 王五 | 男   | 45  | 离异     |
```

下面来逐条解释一下这段编码中所使用的语法标记：

1. “`|`”是表格的单元格之间的分隔符，而“`-`”则是表头行与普通表格行之间的分隔符。

2. 表格中每一列文字的对齐方式将由表头行与普通表格行之间的“`:`”来决定：
   - `:---` 代表左对齐
   - `:--:` 代表居中对齐
   - `---:` 代表右对齐
   - `----` 代表默认状态，依然是左对齐

3. 表格中空格符和“`-`”的数量只是为了代码看起来整洁美观，对其渲染效果没有什么影响。也就是说，上述表格编码在渲染效果上与下面是一致的：

    ```Markdown
    |姓名|性别|年龄|婚姻状况|
    |-|-:|:-:|:-|
    |张三|男|25|未婚|
    |李四|女|35|已婚|
    |王五|男|45|离异|
    ```

下面，就让我们具体来看一下上述编码的渲染效果吧：

![绘制简单表格](img/3-17.png)

但是，这种表格标记只能应对简单的表格，对于那些包含跨行或跨列单元格的复杂表格，它就无能为力了。这时候，我们就需要利用`Markdown`对`HTML`的兼容性，使用`HTML`的`<table>`标签来完成这种复杂的表格了，譬如：

```html
<table>
    <tr>
        <th rowspan=4>会员登记表</th>
        <th>姓名</th>
        <th colspan=3>个人信息</th>
    </tr>
    <tr>
        <td>张三</td><td>男</td><td>25</td><td>未婚</td>
    </tr>
    <tr>
        <td>李四</td><td>女</td><td>35</td><td>已婚</td>
    </tr>
    <tr>
        <td>王五</td><td>男</td><td>45</td><td>离异</td>
    </tr>
</table>
```

如你所见，我们在这里利用`<td>`标签的`colspan`和`rowspan`属性实现了表格中单元格的跨行和跨列，其渲染效果如下：

![绘制复杂表格](img/3-18.png)

当然，这也就意味着，我们在设计网页时用于绘制表格的那些技巧也都可以运用在这里，但请注意，使用`Markdown`写作的目的之一，就是希望将表现语义的元素与表现样式的元素分而治之。所以，我们在`Markdown`中使用`HTML`标签时也应该坚持这一原则，尽量只专注于内容的表达，而对于内容的呈现样式则尽量交由后续工作来处理（譬如上图中的“会员登记表”这五个字，似乎应该设定为在单元格中纵向显示）。

在掌握了这两种绘制表格的方式之后，我们就可以回到论文中去整理那些表格了，譬如：

![论文中的表格](img/3-19.png)

### 3.3.2 引用外部图形

在写作计算机专业论文的过程中，我们通常会需要用到各种各样的图形，以弥补文字在论述能力上的不足。这些图形总体上可分为**引用图形**和**生成图形**两大类。其中，**引用图形**指的是来自论文外部的实物照片、屏幕截图以及第三方制作的图表等。而**生成图形**则通常指的是用特定代码自动生成的图形，包括流程图、序列图、甘特图等。现在，我们先来看第一类。

在`Markdown`中，引用外部图形的语义元素对应的是`HTML`的`<img>`语法，它的语法和网页超链接非常类似，即：

```Markdown
![引用图形的文字说明](引用图形的URL)
```

在这里。`引用图形的URL`既可以是一个HTTP协议的网络URL，也可以是一个绝对路径或相对路径形式的本地URL。譬如：

```Markdown
这里有两张引用图形，一张来自网络：

![来自网络的图形](http://www.newasp.net/attachment/soft/2015/0713/085610_78002493.png)

另一张来自本地计算机：

![来自本地计算机的图形](./1-1.jpg)
```

其渲染效果如下：

![引用图形的语法](img/3-20.png)

当然，如果我们觉得URL部分的字符串过长，影响文档的整洁美观，也可以采用另一种分离式的引用语法。即在图形引用之处为该URL设置一个别名，然后将该别名所代表的URL写在文档最后的注释区即可。譬如，对于上面那张来自网络的图形，我们还可以这样编码：

```Markdown
<!-- 正文中 -->
这里有两张引用图形，一张来自网络：

![来自网络的图形][img1]

另一张来自本地计算机：

![来自本地计算机的图形](./1-1.jpg)

<!-- 继续其他内容 -->

<!-- 注释区 -->
[img1]:http://www.newasp.net/attachment/soft/2015/0713/085610_78002493.png
```

我们可以看到，上述编码的渲染效果与之前是完全一致的：

![引用图形的分离式语法](img/3-21.png)

接下来，我们再来看看如何在`Markdown`中用特定代码自动生成图形。

### 3.3.3 自动生成图形

在`Markdown`的诸多扩展中，`PlantUML`和`Mermaid`无疑是目前使用最多的，用于自动生成图形的两款扩展。接下来，我们就以`Mermaid`为例来介绍一下如何在`Markdown`文档中自动生成图形吧！

`Mermaid`是一个用于自动生成流程图、序列图、甘特图等UML图形的`JavaScript`程序库。正是由于这是一个JS库，所以它实际生成的并不是真正的“图形”，而是一段`HTML`代码，这让它可以更好地融入`Markdown`文档中。当然，我们在这里只介绍如何用`Mermaid`库来生成*流程图*和*序列图*，让大家对如何在`Markdown`文档中自动生成图形有一个总体上的认知。如果想更深入更全面地学会这个库，还请读者自行查阅`Mermaid`库的官方文档[^1]。

#### 3.3.3.1 流程图

众所周知，流程图实际上是对工作流的一种图形化表示，主要用于对程序的控制流和数据流进行建模，是最常用的UML行为图之一。所以既然是要对工作流进行建模，那么定义流程图的第一步就是要先确定流程的走向。在`Mermaid`中，描述流程图走向的语法如下：

    ```Mermaid
    graph [流程图的走向]
      [其他描述语句...]
    ```

首先，要想在`Markdown`文档中使用`Mermaid`库生成图形，我们需要将相关的代码区块标识为“`Mermaid`”，这样文档的阅读器或转换器才能识别出这是一段`Mermaid`代码，并调用相关引擎里来生成图形。然后，对于“`[流程图的走向]`”，我们可以有以下四种选择：

| 用词 | 含义    |
|-----|---------|
| TB  | 从上到下  |
| BT  | 从下到上  |
| RL  | 从右到左  |
| LR  | 从左到右  |

下面，我们继续来关注“`[其他描述语句...]`”的部分。在这一部分的工作中，首先要做的是定义流程图中的“节点”，这些“节点”代表了工作流中的开始、结束、决策、动作等要素。在`Mermaid`中，每个“节点”都需要设置一个id，以及节点的形状与其中的文字，譬如：

    ```Mermaid
    graph LR
      id1((A)) --> id2((B))
      id2 --> id3((C))
      id3 --> id1
    ```

其渲染效果如下：

```Mermaid
graph LR
  id1((A)) --> id2((B))
  id2 --> id3((C))
  id3 --> id1
```

在这里，`id1`、`id2`、`id3`分别是流程图中三个“节点”的id，而关于这些“节点”的形状，我们可以有下面几种选择：

| 节点类型      | 相关说明      |
|--------------|-------------|
| `id[文字]`   | 矩形节点      |
| `id(文字)`   | 圆角矩形节点   |
| `id((文字))` | 圆形节点      |
| `id>文字]`   | 右向旗帜状节点 |
| `id{文字}`   | 菱形节点      |

请注意：如果"节点"中的文字中包含标点符号，需要用双引号把整段文字括起来。如果希望在文字中使用换行，请使用“`<br/>`”来替代换行。

在定义完"节点"之后，接下来就需要定义这些“节点”之间的“连线”了，在这部分，我们同样可以有以下几种选择：

| 连线类型    | 相关说明      |
|------------|-------------|
| `>`        | 添加尾部箭头  |
| `-`        | 不添加尾部箭头 |
| `--`       | 单线         |
| `--text--` | 单线上加文字   |
| `==`       | 粗线         |
| `==text==` | 粗线加文字    |
| `-.-`      | 虚线         |
| `-.text.-` | 虚线加文字    |

除此之外，我们还可以在流程图中设置一个子图，子图的语法如下：

    ```Mermaid
    graph [流程图的走向]
      [父图描述语句...]
      subgraph [子图名称]
        [子图描述语句...]
      end
    ```

现在，让我们综合一下刚才学到的语法，试着来画一张流程图吧。例如，我们在VSCode编辑中输入如下代码：

    ```Mermaid
    graph LR
      id1(圆角矩形)--普通线-->id2[矩形]
      subgraph 子流程
        id2==粗线==>id3{菱形}
        id3-.虚线.->id4>右向旗帜]
        id3--无箭头---id5((圆形))
      end
    ```

只要我们安装了与`Mermaid`相关的预览插件（譬如“Mermaid Preview”插件），应该就会看到如下效果：

![用Mermaid生成流程图](img/3-22.png)

#### 3.3.3.2 序列图

序列图也属于UML行为图中的一种，它的主要作用是描述既定活动序列上的交互行为，通常用来表示相关某一活动中的动作顺序，它的每一条消息都对应了一个动作或者触发状态转换的事件。在`Mermaid`中，定义序列图的语法如下：

    ```Mermaid
    sequenceDiagram
      [参与者1][消息线][参与者2]:[消息文本]
      ...
    ```

例如，假设我们想描述一个对话序列，就可以这样：

    ```Mermaid
    sequenceDiagram
      A ->> B: 你最喜欢的小说是什么？
      B ->> A: 《福尔摩斯探案集》！
    ```

其渲染效果如下：

```Mermaid
sequenceDiagram
  A ->> B: 你最喜欢的小说是什么？
  B ->> A: 《福尔摩斯探案集》！
```

在这里，A和B都是该对话序列的“`[参与者]`”。当然，这是一个最简单的序列图，如果某活动序列中有多个“`[参与者]`，我们也可以单独用`participant`关键字来标明它们，譬如：

    ```Mermaid
    sequenceDiagram
      participant A
      participant B
      participant C
      ...
    ```

而且，我们还可以采用`participant [别名] as [参与者]`的形式，为相关参与者设置别名，譬如：

    ```Mermaid
    sequenceDiagram
      participant A as Alice
      participant B as Bill
      participant C as Chioe
      ...
    ```

同样地，在定义完“`[参与者]`”之后，我们还需要定义它们之间的“`[消息线]`”。对于“`[消息线]`”，`Mermaid`为我们提供了以下几种选择：

| 消息线类型 | 具体说明                |
|----------|------------------------|
| `->`     | 无箭头的实线             |
| `-->`    | 无箭头的虚线             |
| `->>`    | 有箭头的实线             |
| `-->>`   | 有箭头的虚线             |
| `-x`     | 末端为叉的实线（表示异步） |
| `--x`    | 末端为叉的虚线（表示异步） |

最后一部分是每一个序列的“`[消息文本]`”，这代表的是序列参与者之间所传递的消息内容，譬如在上面的例子中，A抛给B的消息是“`你最喜欢的小说是什么？`”，而B回复给A的消息则是“`《福尔摩斯探案集》！`”。

除了以上这些序列图的基本元素之外，我们还可以在序列图中加入一些更详细的信息。譬如标记相关消息的处理状态：

- 在消息线末尾增加 + ，则消息接收者进入当前消息的“处理中”状态。
- 在消息线末尾增加 - ，则消息接收者离开当前消息的“处理中”状态。
  

或者直接用以下语法来标记明某个参与者进入“处理中”状态：

    ```Mermaid
    activate [参与者]
    ```

再譬如，我们可以在某些指定位置上添加一些标注，其语法如下：

    ```Mermaid
    Note [标注位置] [参与者]: [标注文字]
    ```

在这里，对于”`[标注位置]`“的描述，我们可以有以下几种选择：

| 位置描述    | 具体说明                |
|------------|-----------------------|
| `right of` | 在参与者的右侧           |
| `left of`  | 在参与者的左侧           |
| `over`     | 在当中，可以横跨多个参与者 |

最后，我们还可以在序列图中标记一些控制消息传递的控制结构，其语法如下：

- **循环结构**：
  
        ```Mermaid
        loop [循环条件]
          [循环体描述语句]
        end
        ```

- **条件判断**：

        ```Mermaid
        alt [条件1 描述]
          [分支1 描述语句]
        else [条件2 描述]  # else 分支可选
          [分支2 描述语句]
        else ...
          ...
        end
        ```

下面，让我们综合一下刚才学到的语法，试着来画一张序列图吧。例如，我们在VSCode编辑中输入如下代码[^2]：

    ```Mermaid
    sequenceDiagram
      participant Alice
      participant Bob
      Alice->John: Hello John, how are you?
      loop Healthcheck
        John->John: Fight against hypochondria
      end
      Note right of John: Rational thoughts <br/>prevail...
      John-->Alice: Great!
      John->Bob: How about you?
      Bob-->John: Jolly good!
    ```

同样地，只要我们安装了与`Mermaid`相关的预览插件，应该就会看到如下效果：

![用Mermaid生成序列图](img/3-23.png)

## 本章小结

在这一章中，我们首先介绍了如何用VSCode编辑器创建一个`Markdown`文档项目。然后，我们从组织论文的文本切入，依次介绍了如何在`Markdown`文档中进行文本的分段和换行、强调重点、引用外部文字和图片、展现程序代码以及绘制表格。最后，我们还以用`Mermaid`库生成流程图和序列图为例，介绍了如何在`Markdown`文档中自动生成图形。

到目前为止，我们已经介绍了用`Markdown`撰写一篇计算机专业的大学论文所需的大部分基本技能，唯一尚未提及的是关于数学问题的讨论，这正是我们在下一章中要讨论的问题。

[^1]:注释：官方网站：https://mermaidjs.github.io/

[^2]:注释：这段代码来自Mermaid的官方示例。
